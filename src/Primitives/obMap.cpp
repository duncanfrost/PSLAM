#include "obMap.h"

#include "../AmoDefinesParameters.h"


obMap::obMap()
{
	KeyFrameList.reserve(500);
}

int obMap::createUnconnectedNewKF(cv::Mat &_img)
{
	//create KF and extract all feature and descriptors
	/*int idNewKF=KeyFrameList.size();
	KeyFrame newKF(idNewKF,_img,HomogeneousMatrix());//set position to identity
	
	std::cout<<"create KF "<<idNewKF<<std::endl;
	KeyFrameList.push_back(newKF);*/
	
	int idNewKF=KeyFrameList.size();
	KeyFrame newKF;//set position to identity
	
	KeyFrameList.push_back(newKF);
	
	KeyFrameList[idNewKF].Init(idNewKF,_img,HomogeneousMatrix());
	
	return idNewKF;
}

struct linkFeature//one per feature per neigbor
{
	int idGoodFeature;//index of good feature in neigbor, -1 if not match with any good feature of this neigbor
	//bool matchedWithPoint;//is feature already linked to 3D point
	//KeyFrame *ptKForigin;
	//int idPoint;		
};

void obMap::createNewKeyFrame(cv::Mat &_current_img,HomogeneousMatrix &_pose)
{
    coutGreen << "Creating new keyframe." << endlGreen;
	int idNewKF=KeyFrameList.size();
	std::cout<<"Create KF "<<idNewKF<<std::endl;
	KeyFrame newKF;//set position to identity
	
	KeyFrameList.push_back(newKF);
	KeyFrameList[idNewKF].Init(idNewKF,_current_img,_pose);	
}

void obMap::createNewKeyFrame(cv::Mat &_current_img,HomogeneousMatrix &relPose,int &idrelKF,std::vector<int> &id_closestKF)
{
    coutGreen << "Creating new keyframe." << endlGreen;
	int idNewKF=KeyFrameList.size();
	std::cout<<"Create KF "<<idNewKF<<std::endl;
	KeyFrame newKF;//set position to identity
	
	KeyFrameList.push_back(newKF);
	KeyFrameList[idNewKF].Init(idNewKF,_current_img,relPose*KeyFrameList[idrelKF].getPose());	
	
	//remove neigbors with not enough matches
	//indeed afterward all of the neigbors are used to create inter KF edge constraint
	//while to be valid an edge must have at least 3 features shared by KFs 
	for(int i=0;i<id_closestKF.size();i++)
		
		if(KeyFrameList[id_closestKF[i]].getLastNumberMatches()<MIN_MATCHES_EDGE)
		{
			id_closestKF.erase(id_closestKF.begin()+i);
			i--;
		}
	
	//use the neigbor with best fundamental matrix score to 
	//update ministereo of new KeyFrame
	int id_max_fundamental=id_closestKF[0];
	float best_fundamental_score=0;
	for(int i=0;i<id_closestKF.size();i++)
	{
		float fund_score=KeyFrameList[id_closestKF[i]].getLastFundamentalScore();
		std::cout<<"KF "<<id_closestKF[i]<<" fund_score= "<<fund_score<<std::endl;
		if(best_fundamental_score<fund_score)
		{
			best_fundamental_score=fund_score;
			id_max_fundamental=id_closestKF[i];
		}
	}
	//update new KF with best neigbor
	//use inverse of matches and inverse of 3D movement 
    std::cout<<"id_max_fundamental = "<<id_max_fundamental;
	std::vector<p_match> matches_bestNeigbor=KeyFrameList[id_max_fundamental].getCurrentMatches();
	HomogeneousMatrix relPose_bestNeigbor=KeyFrameList[id_max_fundamental].getRelativePose();
	KeyFrameList[idNewKF].useNeigborForInitLocalStereo(KeyFrameList[id_max_fundamental].getImg_p(0),matches_bestNeigbor,relPose_bestNeigbor,myCamera);
	
	//create link with neigbors (if enough overlap?)
	std::cout<<"Create edges"<<std::endl;
	for(int i=0;i<id_closestKF.size();i++)
	{
	 	int id_neigbor=id_closestKF[i];
		KeyFrame &kf=KeyFrameList[id_neigbor];
	  
		//add neigbor to new KF
		NeigbourKFNew newNeigbor1;
		newNeigbor1.relative_scale=1.;
		newNeigbor1.neighboring_kf=id_neigbor;
		//here relative pose could be computed also from relative pose with idrelKF and rel pose between kf idrelKF and current neigbor but would be resulting on storing redundant information
		//here choose to compute it only from matches between current image and current neigbor so that we use most of the information
		kf.computeRelativeCurrentPoseWithLocalFeatures(myCamera);
		newNeigbor1.relative_poses=kf.getRelativePose();
		newNeigbor1.Homography=kf.getHomography();//homography between two images 
		newNeigbor1.matches=kf.getCurrentMatches();
		newNeigbor1.edgeScore=0;//will be updated if 3D points are generated by this link
		//get information matrix wrt relative pose using local features of both keyframes
		//this information can be used with relative_poses in pose graph optimisation (if no PGO is used then can comment that)
		//TODO: include scale in it
		//newNeigbor1.InformationMatrixPose=getInformationMatrixMatches(idNewKF,newNeigbor1,myCamera);
		//instead compute relative pose and scale using local features adjustment
		//getRelativePoseAndScale(idNewKF,id_neigbor,newNeigbor1.relative_scale,newNeigbor1.relative_poses,newNeigbor1.Informationscale,newNeigbor1.InformationMatrixPose);
		
		
		KeyFrameList[idNewKF].addNeighbour(newNeigbor1);
		
		//add neigbor to close KFs
		NeigbourKFNew newNeigbor2;
		newNeigbor2.relative_scale=1.;
		newNeigbor2.neighboring_kf=idNewKF;
		newNeigbor2.relative_poses=kf.getRelativePose().inverse();				
		Eigen::FullPivLU<MatrixXf> lu(kf.getHomography());
		newNeigbor2.Homography=lu.inverse();//homography between two images 
		newNeigbor2.edgeScore=0;//will be updated if 3D points are generated by this link
		for(int m=0;m<newNeigbor1.matches.size();m++)
			newNeigbor2.matches.push_back(newNeigbor1.matches[m].reverse());
		//newNeigbor2.InformationMatrixPose=newNeigbor1.InformationMatrixPose;
		//getRelativePoseAndScale(id_neigbor,idNewKF,newNeigbor2.relative_scale,newNeigbor2.relative_poses,newNeigbor2.Informationscale,newNeigbor2.InformationMatrixPose);
		KeyFrameList[id_neigbor].addNeighbour(newNeigbor2);
	}
	
	checkNeigborsForPoints(idNewKF);
	
	//change tracker info	
	id_closestKF.push_back(idNewKF);
	idrelKF=idNewKF;
	relPose=HomogeneousMatrix();
}
void obMap::createNewEdge(int kfIdFrom,int kfIdTo)
{
	KeyFrame &kf=KeyFrameList[kfIdTo];
	KeyFrame &kfFrom=KeyFrameList[kfIdFrom];
  
	//add neigbor to new KF
	//add neigbor to close KFs
	//add neigbor to new KF
	NeigbourKFNew newNeigbor2;
	newNeigbor2.relative_scale=1.;
	newNeigbor2.neighboring_kf=kfIdFrom;
	newNeigbor2.relative_poses=kfFrom.getRelativePose().inverse();//kfFrom has been used to do matching so should have relative pose in it				
	Eigen::FullPivLU<MatrixXf> lu(kf.getHomography());
	newNeigbor2.Homography=lu.inverse();//homography between two images 
	newNeigbor2.edgeScore=0;//will be updated if 3D points are generated by this link
	newNeigbor2.matches=KeyFrameList[kfIdFrom].getCurrentMatches();
	//newNeigbor2.InformationMatrixPose=getInformationMatrixMatches(kfIdTo,newNeigbor2,myCamera);
	
	KeyFrameList[kfIdTo].addNeighbour(newNeigbor2);
      
	NeigbourKFNew newNeigbor1;
	newNeigbor1.relative_scale=1.;
	newNeigbor1.neighboring_kf=kfIdTo;
	//WARNING here relative pose could be computed also from relative pose with idrelKF and rel pose between kf idrelKF and current neigbor
	//here choose to compute it only from matches between current image and current neigbor
	kf.computeRelativeCurrentPoseWithLocalFeatures(myCamera);
	//kf.computeRelativeCurrentPoseWithMatchedFeatures(myCamera,&KeyFrameList[0]);
	newNeigbor1.relative_poses=kfFrom.getRelativePose();
	newNeigbor1.Homography=kf.getHomography();//homography between two images 
	for(int m=0;m<newNeigbor2.matches.size();m++)
		newNeigbor1.matches.push_back(newNeigbor2.matches[m].reverse());
	//newNeigbor1.InformationMatrixPose=newNeigbor2.InformationMatrixPose;
	newNeigbor1.edgeScore=0;//will be updated if 3D points are generated by this link
	KeyFrameList[kfIdFrom].addNeighbour(newNeigbor1);
	
	//TODO: improve getRelativePoseAndScale: not very robust at the moment
	//use 200 iteration as might be a loop closure and be far from optimal scale
	NeigbourKFNew &newNeigbor1ref=*KeyFrameList[kfIdFrom].getPtNeigbour(KeyFrameList[kfIdFrom].getNbNeigbours()-1);
	NeigbourKFNew &newNeigbor2ref=*KeyFrameList[kfIdTo].getPtNeigbour(KeyFrameList[kfIdTo].getNbNeigbours()-1);
	getRelativePoseAndScale(kfIdTo,kfIdFrom,newNeigbor2ref.relative_scale,newNeigbor2ref.relative_poses,newNeigbor2ref.Informationscale,newNeigbor2ref.InformationMatrixPose,400);
	//help init of inverse
	//newNeigbor1ref.relative_scale=1./newNeigbor2ref.relative_scale;
	//newNeigbor1ref.relative_poses=newNeigbor2ref.relative_poses.inverse();
	//newNeigbor1ref.relative_poses.set_translation(newNeigbor1ref.relative_scale*newNeigbor1ref.relative_poses.get_translation());
	getRelativePoseAndScale(kfIdFrom,kfIdTo,newNeigbor1ref.relative_scale,newNeigbor1ref.relative_poses,newNeigbor1ref.Informationscale,newNeigbor1ref.InformationMatrixPose,400);
	
	checkNeigborsForPoints(kfIdFrom,true);
}


void obMap::checkNeigborsForPoints(int cKF,bool recheckMatchedFeatures)
{
	KeyFrame &KFc=KeyFrameList[cKF];
	std::cout<<"\tcheckNeigborsForPoints "<<cKF<<" nb neigbors = "<<KFc.getNbNeigbours()<<std::endl;
	
 	int nbNeigbor=KFc.getNbNeigbours();
	if(nbNeigbor>0)
	{
		NeigbourKFNew *neigbours=KFc.getPtNeigbour(0);
		
		//create map points from tracks that gather measures from different KFs to be used by BA
		//Basically here we have a set of matches to neigbors features, these features are potentially to neigbor local 3d features
		//and potentially this local features are matches with existing map points
		//=> need to gather all this info to know all the features with no link to 3D points and 
		//all the 3D points that are therefore duplicated points and need to be merged
		
		//init to no match:
		linkFeature linkingInformation[KFc.getNbLocalBestFeatures()][nbNeigbor];
		for(int f=0;f<KFc.getNbLocalBestFeatures();f++)
			for(int i=0;i<nbNeigbor;i++)
				linkingInformation[f][i].idGoodFeature=-1;
			
			
		for(int i=0;i<nbNeigbor;i++)
		{
			NeigbourKFNew &newNeigbor1=neigbours[i];
			int id_neigbor=newNeigbor1.neighboring_kf;
			
			std::cout<<"\taccumulate linking goodFeatures with neigbor KF "<<id_neigbor<<std::endl;
			for(int m=0;m<newNeigbor1.matches.size();m++)
				if(newNeigbor1.matches[m].i1c!=-1)//will not be match in current or neigbor=> pass
			{
				//check if has 3D estimation in current ministereo
				int id_feat_c=KFc.indexCandidateFeatureFromVisoId(newNeigbor1.matches[m].i1c);
				if(id_feat_c!=-1)
				  	//if current feature is already matched then should not be rechecked:
					//if new feature local is created in a neigbor then mean that the neigbor
					//has to be rechecked and the linkage of measure will be done at that point
					//except when close loops, then can have already matched features matched with new things
					if(recheckMatchedFeatures || !KFc.getPtLocalBestFeatures(id_feat_c)->matched)
				{
					//check if has 3D estimation in neigbor ministereo
					int id_feat_n=KeyFrameList[id_neigbor].indexCandidateFeatureFromVisoId(newNeigbor1.matches[m].i1p);
					if(id_feat_n!=-1)
					{
						linkingInformation[id_feat_c][i].idGoodFeature=id_feat_n;
					}
				}			
			}

		}
		
		//use all linkingInformation to (create point) or (merge) or (create and merge points)
		std::cout<<"\tUse linking goodFeatures to update points"<<std::endl;
		int nb_feat_matched_to_other_feat=0;
		for(int f=0;f<KFc.getNbLocalBestFeatures();f++)
		{	
			bool verb_proc=false;
			//verb_proc=f<20;
			if(verb_proc)std::cout<<"\tcheck feature "<<f<<std::endl;
			
			//check if have any match between current local feature and local feature of other KF
			bool hasAnyMatches=false;
			for(int n=0;n<nbNeigbor;n++)
				hasAnyMatches=hasAnyMatches||(linkingInformation[f][n].idGoodFeature!=-1);
			
			//if no matches then nothing to do
			if(!hasAnyMatches)continue;
			else nb_feat_matched_to_other_feat++;
			
			//current feature local
			uptoscaleFeature &feat_c=*KFc.getPtLocalBestFeatures(f);	
			//if current feature is already matched then should not be rechecked:
			//if new feature local is created in a neigbor then mean that the neigbor
			//has to be rechecked and the linkage of measure will be done at that point
			//if(feat_c.matched)continue;
			
			//pointer to current point
			MapPoint *currentPoint;
			KeyFrame *kfOriginCurrentPoint;
		
			if(!feat_c.matched)
			{
				//use current feature to initialise currentPoint
				MapPoint _newPoint;
				int id_new_mapPoint=KFc.getNbMapPoint();
				_newPoint.setId(id_new_mapPoint);
				Vector3f localCoord=toHomogeneous(feat_c.posRef)*feat_c.depthInRef;
				Vector3f AbsoluteCoord=KFc.getPose().inverse()*localCoord;
				_newPoint.updatePosition(AbsoluteCoord);
#ifdef SAVE_POINT_COLOR			
				//_newPoint.setGrayVal(feat_c.grayVal);
				_newPoint.setCol(feat_c.col);
#endif
				_newPoint.setWeight(feat_c.scoreFundamentalOrigin);
				if(verb_proc)std::cout<<"\tCreate point "<<id_new_mapPoint<<std::endl;
				if(verb_proc)std::cout<<"\t\tCoord: "<<AbsoluteCoord.transpose()<<std::endl;
				
				//add point to KF
				//add it to the neigbor
				KFc.addMapPoint(_newPoint);
				currentPoint=KFc.getPtMapPoint(id_new_mapPoint);
				kfOriginCurrentPoint=&KFc;
				//add views
				currentPoint->addView(cKF,feat_c.i1p);
							
				//make link from feature to point
				feat_c.matched=true;
				feat_c.ptKForigin=kfOriginCurrentPoint;
				feat_c.idPoint=id_new_mapPoint;
			}
			else
			{
				kfOriginCurrentPoint=feat_c.ptKForigin;
				currentPoint=kfOriginCurrentPoint->getPtMapPoint(feat_c.idPoint);
				if(verb_proc)std::cout<<"\tCurrent Point : idKf = "<<kfOriginCurrentPoint->getId()<<" idPoint = "<<feat_c.idPoint<<" =? "<<currentPoint->getId() <<std::endl;
			}
			
			
			//check if has some matches linked to 3D point
			for(int n=0;n<nbNeigbor;n++)
				if(linkingInformation[f][n].idGoodFeature!=-1)
			{
				NeigbourKFNew &newNeigbor1=neigbours[n];
				int id_neigbor=newNeigbor1.neighboring_kf;
				int &idFeatInNeigbor=linkingInformation[f][n].idGoodFeature;
				if(verb_proc)std::cout<<"\t\tlinked to kf "<<id_neigbor<<" feat id = "<<idFeatInNeigbor<<std::endl;
				uptoscaleFeature &feat_n=*KeyFrameList[id_neigbor].getPtLocalBestFeatures(idFeatInNeigbor);
				bool isLinked=feat_n.matched;
				if(!isLinked)
				{
					if(verb_proc)std::cout<<"\t\t\tno 3d match in link"<<std::endl;
					//has already a point in currentPoint=> just need to add view to it
					currentPoint->addView(id_neigbor,feat_n.i1p);
					//and make link from feature to point
					feat_n.matched=true;
					feat_n.ptKForigin=kfOriginCurrentPoint;
					feat_n.idPoint=currentPoint->getId();
					
					Vector3f localCoordn=toHomogeneous(feat_n.posRef)*feat_n.depthInRef;
					Vector3f AbsoluteCoordn=KeyFrameList[id_neigbor].getPose().inverse()*localCoordn;
					//do average of coordinates of views weighted by scoreLocalFeature
					Vector3f new_position=1./(currentPoint->getWeight()+feat_n.scoreFundamentalOrigin)*(currentPoint->getWeight()*currentPoint->getPosition()+feat_n.scoreFundamentalOrigin*AbsoluteCoordn);					
					currentPoint->updatePosition(new_position);
					
#ifdef SAVE_POINT_COLOR			
					//unsigned char newGrayVal=1./(currentPoint->getWeight()+feat_n.scoreFundamentalOrigin)*(currentPoint->getWeight()*currentPoint->getGrayVal()+feat_n.scoreFundamentalOrigin*feat_n.grayVal);
					//currentPoint->setGrayVal(feat_c.grayVal);
					unsigned char newCol[3];
					for(int i=0;i<3;i++)
						newCol[i]=1./(currentPoint->getWeight()+feat_n.scoreFundamentalOrigin)*(currentPoint->getWeight()*currentPoint->getCol(i)+feat_n.scoreFundamentalOrigin*feat_n.col[i]);
					currentPoint->setCol(newCol);
#endif
					
					//add weight to score
					currentPoint->setWeight(currentPoint->getWeight()+feat_n.scoreFundamentalOrigin);
				}
				else
				{
					if(verb_proc)std::cout<<"\t\t\t3d match in link"<<std::endl;
					if(verb_proc)std::cout<<"\t\t\tinfo feat = idKF : "<<feat_n.ptKForigin->getId()<<" idPoint = "<<feat_n.idPoint<<std::endl;

					MapPoint *PointToMerge=feat_n.ptKForigin->getPtMapPoint(feat_n.idPoint);
					
					if(!PointToMerge->isUsed())
					{
						std::cout<<"\t\t\tPointToMerge not used... weird, matching should have been suppressed"<<std::endl;
					}
					//std::cout<<"nb View = "<<PointToMerge->nbViews()<<std::endl;
					
					//might have one feature matched to two neigbors pointing at same point
					//in that case would have PointToMerge=currentPoint and would have to do nothing
					//if(PointToMerge!=currentPoint)
					if(feat_n.ptKForigin->getId()!=feat_c.ptKForigin->getId() || feat_n.idPoint!=feat_c.idPoint)
					{
						//add all the view of pointToMerge into current point
						for(int v=0;v<PointToMerge->nbViews();v++)
						{
							//get corresponding feature to change its pointer from pointToMerge to currentPoint
							int id_feat_in_view=KeyFrameList[PointToMerge->getView(v)].indexCandidateFeatureFromVisoId(PointToMerge->getI1p(v));
							if(verb_proc)std::cout<<"\t\t\t\tpass through view "<<v<<" idKF = "<<PointToMerge->getView(v)<<" id_feat_in_view = "<<id_feat_in_view<<std::endl;
							if(id_feat_in_view!=-1)
							{
								//change pointer of feature temp
								uptoscaleFeature &feat_v=*KeyFrameList[PointToMerge->getView(v)].getPtLocalBestFeatures(id_feat_in_view);
								feat_v.ptKForigin=kfOriginCurrentPoint;
								feat_v.idPoint=currentPoint->getId();
								
								//add view to current point
								currentPoint->addView(PointToMerge->getView(v),PointToMerge->getI1p(v));	
							}
							else
								if(verb_proc)std::cout<<"problem finding feature from view"<<std::endl;
							
						}
						if(verb_proc)std::cout<<"\t\t\t\tfeat_n.idPoint : "<<feat_n.idPoint<<" currentPoint->getId() = "<<currentPoint->getId()<<std::endl;	
						
						//average point position and set weight
						Vector3f new_position=(currentPoint->getWeight()*currentPoint->getPosition()+PointToMerge->getWeight()*PointToMerge->getPosition())/(currentPoint->getWeight()+PointToMerge->getWeight());
						currentPoint->updatePosition(new_position);
						
#ifdef SAVE_POINT_COLOR			
						//unsigned char newGrayVal=(currentPoint->getWeight()*currentPoint->getGrayVal()+PointToMerge->getWeight()*PointToMerge->getGrayVal())/(currentPoint->getWeight()+PointToMerge->getWeight());
						//currentPoint->setGrayVal(newGrayVal);
						
						unsigned char newCol[3];
						for(int i=0;i<3;i++)
							newCol[i]=(currentPoint->getWeight()*currentPoint->getCol(i)+PointToMerge->getWeight()*PointToMerge->getCol(i))/(currentPoint->getWeight()+PointToMerge->getWeight());
						currentPoint->setCol(newCol);
#endif
						currentPoint->setWeight(currentPoint->getWeight()+PointToMerge->getWeight());
						
						//remove PointToMerge
						PointToMerge->removeViews();
						PointToMerge->setAsBad();
					}
					else 
					{
						if(verb_proc)std::cout<<"\t\t\tFeatures already matched to same point : idKf = "<<feat_n.ptKForigin->getId()<<" idPoint = "<<feat_n.idPoint<<std::endl;
					}
					
					
						
				}
				//if(verb_proc)std::cout<<"\t\tUpdate edge score"<<std::endl;
				//update edgeScore beween two keyframes
				float edgeScoreUpdate=feat_c.scoreFundamentalOrigin*feat_n.scoreFundamentalOrigin;
				//update edge cKF->id_neigbor and  inverse
				KFc.getPtNeigbour(KFc.isNeigbour(id_neigbor))->edgeScore+=edgeScoreUpdate;
				KeyFrameList[id_neigbor].getPtNeigbour(KeyFrameList[id_neigbor].isNeigbour(cKF))->edgeScore+=edgeScoreUpdate;	
				
				//TODO update optimal relative pose and scale and corresponding information matrix

			}	
		}
		std::cout<<"nb_feat_matched_to_other_feat = "<<nb_feat_matched_to_other_feat<<std::endl;
	
	}
	
	//set Keyframe as checked
	KFc.LocalBestFeaturesHaveBeenChecked();
}


std::vector<int> obMap::getDirectNeigbors(std::vector<int> &_KFs)
{
	std::vector<int> res;
	for(int i=0;i<_KFs.size();i++)
	{
		for(int j=0;j<KeyFrameList[_KFs[i]].getNbNeigbours();j++)
		{
			int neigb=KeyFrameList[_KFs[i]].getPtNeigbour(j)->neighboring_kf;
			//add kf if not in list and not in src
			if(std::find(_KFs.begin(), _KFs.end(), neigb)==_KFs.end())
				if(std::find(res.begin(), res.end(), neigb)==res.end())
				res.push_back(neigb);
		}
	}
	return res;
}
std::vector<int> obMap::getDirectNeigborsWithGoodEstimatedOverlap(std::vector<int> &_KFs)
{
	std::vector<int> res;
	std::vector<int> alreadyChecked;
	for(int i=0;i<_KFs.size();i++)
	{
		for(int j=0;j<KeyFrameList[_KFs[i]].getNbNeigbours();j++)
		{
			KeyFrame &kfc=KeyFrameList[_KFs[i]];
			
			int neigb=kfc.getPtNeigbour(j)->neighboring_kf;
			KeyFrame &kfn=KeyFrameList[neigb];
			
			//if not already in neigborhood
			if(std::find(_KFs.begin(), _KFs.end(), neigb)==_KFs.end())
			{
				//if not in res and not already checked, check overlap with current frame using homogrphy composition
				if(std::find(res.begin(), res.end(), neigb)==res.end())
				if(std::find(alreadyChecked.begin(), alreadyChecked.end(), neigb)==alreadyChecked.end())
				{
					//homography from neigbor to current frame = H(_KFs[i] to current frame)*H(neigbor to _KFs[i])
					//want I(H(pix))=I_refn(pix)
					//while have in kf I(Hrefc(pix))=I_refc(pix) and in neigbor I_refc(Hneigb(pix))=I_refn(pix) 
					//=>I(Hrefc*Hneigb(pix))=I_refc(Hneigb*pix)=I_refn(pix) 
					kfn.setHomography(kfc.getHomography()*kfc.getPtNeigbour(j)->Homography);
					float overlap=kfn.getOverlapWithLastFrame();
					if(overlap>KFoverlapMin)
						res.push_back(neigb);
					else
						alreadyChecked.push_back(neigb);
				}
			}
		}
	}
	return res;
}

std::vector<int> obMap::getDirectNeigborsWithGoodEstimatedOverlapDepth(std::vector<int> &_KFs,int _d)
{
	std::vector<int> inputKF=_KFs;
	std::vector<int> res;
	std::vector<int> alreadyChecked=_KFs;
	for(int d=0;d<_d;d++)
	{
		std::vector<int> inputKFnext;
		for(int i=0;i<inputKF.size();i++)
		{
			for(int j=0;j<KeyFrameList[inputKF[i]].getNbNeigbours();j++)
			{
				KeyFrame &kfc=KeyFrameList[inputKF[i]];
				
				int neigb=kfc.getPtNeigbour(j)->neighboring_kf;
				KeyFrame &kfn=KeyFrameList[neigb];
				
				//if not already in neigborhood
				//if(std::find(inputKF.begin(), inputKF.end(), neigb)==inputKF.end())//input added to alreadyChecked so done after
				{
					//if not in res and not already checked, check overlap with current frame using homogrphy composition
					if(std::find(alreadyChecked.begin(), alreadyChecked.end(), neigb)==alreadyChecked.end())
					{
						//homography from neigbor to current frame = H(inputKF[i] to current frame)*H(neigbor to inputKF[i])
						//want I(H(pix))=I_refn(pix)
						//while have in kf I(Hrefc(pix))=I_refc(pix) and in neigbor I_refc(Hneigb(pix))=I_refn(pix) 
						//=>I(Hrefc*Hneigb(pix))=I_refc(Hneigb*pix)=I_refn(pix) 
						kfn.setHomography(kfc.getHomography()*kfc.getPtNeigbour(j)->Homography);
						float overlap=kfn.getOverlapWithLastFrame();
						
						//coutRed<<"overlap with KF["<<neigb<<"] = "<<overlap<<endlRed;
						
						if(overlap>KFoverlapMin)
							res.push_back(neigb);
						alreadyChecked.push_back(neigb);
						inputKFnext.push_back(neigb);
					}
				}
			}
		}
		inputKF=inputKFnext;
	}
	return res;
}
void obMap::saveToStream(std::ofstream &fout)
{
	//save pose,image,neigbours,depth info
	int nbKF=KeyFrameList.size();
	fout.write((const char*)&nbKF,sizeof(int));
	
	for(int i=0;i<nbKF;i++)
	{
		std::cout<<"save KF "<<i<<std::endl;
		KeyFrameList[i].saveToStream(fout,&KeyFrameList[0]);
	}
	std::cout<<"save complete"<<std::endl;
}
void obMap::loadFromStream(std::ifstream &fout)
{
	//save pose,image,neigbours,depth info
	int nbKF;
	fout.read((char*)&nbKF,sizeof(int));
	KeyFrameList.resize(nbKF);
	
	for(int i=0;i<nbKF;i++)
	{
		std::cout<<"load KF "<<i<<std::endl;
		KeyFrameList[i].loadFromStream(fout,&KeyFrameList[0]);
	}
}

void obMap::saveToFile(const char *filename)
{
	std::ofstream fout;
	fout.open(filename);
	
	saveToStream(fout);

	fout.close();  
}
void obMap::loadFromFile(const char *filename)
{
	std::ifstream fout;
	fout.open(filename);
	if(!fout.is_open())
		std::cerr<<"obMap::loadFromFile : problem loading file "<<filename<<std::endl;
	else
		loadFromStream(fout);
	fout.close();  
}

void obMap::removeUnusedPoints(int _kfId)
{
	KeyFrame &kfc=*getKF(_kfId);
	
	//if point is not used then have to suppress it; by suppressing it 
	//all position of points in list Mappoint after current point will change;
	//all the views of these points will have their structure changing
	
	//=> instead of suppressing one by one, and changing theses views several time,
	//create LUT going from current id point to id of point in cleaned list
	//int LUT[kfc.getNbMapPoint()];
	
	int p2=0;
	for(int p=0;p<kfc.getNbMapPoint();p++)
	{
		//LUT[p]=p2;
		
		MapPoint &point=*kfc.getPtMapPoint(p);
		if(point.isUsed())
		{
			if(p2!=p)//there has been one or more points suppressed in list before 
			{
				//go through all view of point and change current id==p to p2
				for(int v=0;v<point.nbViews();v++)
				{
					int kfView=point.getView(v);
					int i1pView=point.getI1p(v);
					//get corresponding local feature:
					int id_feat_v=KeyFrameList[kfView].indexCandidateFeatureFromVisoId(i1pView);
					if(id_feat_v!=-1)
					{
						uptoscaleFeature &feat_v=*KeyFrameList[kfView].getPtLocalBestFeatures(id_feat_v);
						if(feat_v.matched)//should be
						{
							feat_v.idPoint=p2;
						}
						
					}
					
				}
				point.setId(p2);
			}
			
			p2++;
		}

	}
	
	for(int p=0;p<kfc.getNbMapPoint();p++)
	{
		MapPoint &point=*kfc.getPtMapPoint(p);
		if(!point.isUsed())
		{
			kfc.removePoint(p);
			p--;
		}
	}
		
	
}
int obMap::getNbMapPoints()
{
	int res=0;
	for(int i=0;i<KeyFrameList.size();i++)
		res+=KeyFrameList[i].getNbMapPoint();
	return res;
	  
}
int obMap::getNbUsedMapPoints()
{
	int res=0;
	for(int i=0;i<KeyFrameList.size();i++)
		res+=KeyFrameList[i].getNbUsedMapPoint();
	return res;
  
}

std::vector<int> obMap::getConnectedKeyframes(std::vector<int> _idkf,int _depth)
{
	std::vector<int> res;
	res=_idkf;
	
	std::vector<int>  newOnes;
	int depthCurrent=0;
	do
	{	
		newOnes.clear();
		newOnes=getDirectNeigbors(res);
		for(int i=0;i<newOnes.size();i++)
		{
			res.push_back(newOnes[i]);
		}
		depthCurrent++;
	}
	while(newOnes.size()!=0 && (_depth==-1 || depthCurrent<_depth));
	
	return res;
}

#include "../TrackEngines/RobustMatching.h"

void obMap::checkForSmallLoop(int _idKF,int _depth_min,int _depth_max)
{
	std::cout<<"Check loop closure for frame = "<<_idKF<<std::endl;
	
	std::vector<int> tooCloseKfs;
	tooCloseKfs.push_back(_idKF);
	
	for(int i=0;i<_depth_min ;i++)
	{
		std::vector<int> tooCloseKfsToAdd=getDirectNeigbors(tooCloseKfs);
		for(int j=0;j<tooCloseKfsToAdd.size();j++)
			tooCloseKfs.push_back(tooCloseKfsToAdd[j]);
	}
	
	std::vector<int> KfsToCheck;
	for(int i=_depth_min;i<_depth_max ;i++)
	{
		std::vector<int> KfsToCheckToAdd=getDirectNeigbors(tooCloseKfs);
		for(int j=0;j<KfsToCheckToAdd.size();j++)
		{
			tooCloseKfs.push_back(KfsToCheckToAdd[j]);
			KfsToCheck.push_back(KfsToCheckToAdd[j]);
		}
	}
	
	
	KeyFrame &KF1=KeyFrameList[_idKF];
	for(int c=0;c<KfsToCheck.size();c++)
	{
		std::cout<<"check with KF = "<<KfsToCheck[c]<<std::endl;
		KeyFrame &KF2=KeyFrameList[KfsToCheck[c]];
		
		//check robust matching between 
		Matrix3f Homography;
		std::vector<p_match> ORBsMatches=checkForLoop(KF1.getImg_p(lvl_Viso),KF2.getImg_p(lvl_Viso),Homography);
		int nbMatchedORBS=ORBsMatches.size();
		std::cout<<"nbMatchedORBS = "<<nbMatchedORBS<<std::endl;
		if(nbMatchedORBS>10)
		{
			//WARNING here we are going to modify current homography of KF
			//to test matching => need to not be in current active windows
			//or would make the tracking fail
			
			//should have homography from KF2 to KF1
			KF1.setHomography(Homography);
			//test matching more refined only if first estimation of homography gives high enough overlap
			float overlap=KF1.getOverlapWithLastFrame();
			std::cout<<"\tHomography found with overlap = "<<overlap<<std::endl;
			if(overlap>0.7)
			{
				std::cout<<"\tgood loop closure candidate => try more refine matching"<<std::endl;
				int nb_matchs=KF1.useNewFrame(KF2.getImg_p(),myCamera);
				Homography=KF1.getHomography();
				float newOverlap=KF1.getOverlapWithLastFrame();
				std::cout<<"\t\toverlap = "<<newOverlap<<std::endl;
				std::cout<<"\t\tnb_matchs = "<<nb_matchs<<std::endl;
				if(nb_matchs>50 && newOverlap>0.7)
				{
					std::cout<<"\t\t\tshould create new link"<<std::endl;
				}
			}
		  
		}
	}
}


MatrixXf obMap::getInformationMatrixMatches(int kfOrig,NeigbourKFNew &neigbor, Camera *myCamera)
{
	KeyFrame &KFc=KeyFrameList[kfOrig];
	KeyFrame &KFn=KeyFrameList[neigbor.neighboring_kf];

	MatrixXf H(6,6);H.setZero();
	std::vector<float> vdErrorSquared;
	HomogeneousMatrix &relPose=neigbor.relative_poses;
	
	for(int m=0;m<neigbor.matches.size();m++)
	{
		p_match &mMatch=neigbor.matches[m];
		//if matches are linked to local features then give info on scale too
		int idFeat_c=KFc.indexCandidateFeatureFromVisoId(mMatch.i1c);
		int idFeat_n=KFn.indexCandidateFeatureFromVisoId(mMatch.i1p);
		if(idFeat_c!=-1 && idFeat_n!=-1)
		{
		uptoscaleFeature *feat_c=KFc.getPtLocalBestFeatures(idFeat_c);
		uptoscaleFeature *feat_n=KFn.getPtLocalBestFeatures(idFeat_n);
		Vector3f scaleError=feat_c->getLocalCoordinates()-relPose*(feat_n->getLocalCoordinates());
		vdErrorSquared.push_back(scaleError.squaredNorm());
		}
	}  
	float sigma_tukey=0;
	if(vdErrorSquared.size()!=0)
		sigma_tukey=getSigmaSquared(vdErrorSquared);
	
	for(int m=0;m<neigbor.matches.size();m++)
	{
		p_match &mMatch=neigbor.matches[m];
		//if matches are linked to local features then give info on scale too
		int idFeat_c=KFc.indexCandidateFeatureFromVisoId(mMatch.i1c);
		int idFeat_n=KFn.indexCandidateFeatureFromVisoId(mMatch.i1p);
		if(idFeat_c!=-1 && idFeat_n!=-1)
		{
			
		uptoscaleFeature *feat_c=KFc.getPtLocalBestFeatures(idFeat_c);
		uptoscaleFeature *feat_n=KFn.getPtLocalBestFeatures(idFeat_n);
		//float add_scales=(scale_c+scale_n);
		//Vector3f scaleError=(1./add_scales)*(scale_c*feat_c->getLocalCoordinates()-relPose*(scale_n*feat_n->getLocalCoordinates()));
		Vector3f scaleError=feat_c->getLocalCoordinates()-(relPose*feat_n->getLocalCoordinates());
		float TukeyCoef=squareRootTukey(scaleError.squaredNorm(),sigma_tukey);
		
		if(TukeyCoef>0)
		{
			//deriv with respect to relPose:
			MatrixXf jac_dp(3,6);
			jac_dp.block(0,0,3,3)=-Matrix3f::Identity();
			//jac_dp.block(0,3,3,3)=GetSkew(relPose*(scale_n*feat_n->getLocalCoordinates()));
			jac_dp.block(0,3,3,3)=GetSkew(relPose*(feat_n->getLocalCoordinates()));	
			H+=TukeyCoef * jac_dp.transpose() * jac_dp;				
		}
		}
	}
	return H;
	
}
struct kf_loc_scal_jac
{
	Vector3f pos_error;//projection error
	int opt_idn;//index of kf in optimisation list
	MatrixXf de_dpn;//jacobian wrt kf position
	Vector3f de_dsn;//jacobian wrt kf scale
	float weight;
};
void obMap::getRelativePoseAndScale(int _kfcurr,int _kfneigb,float &optRelScale,HomogeneousMatrix &optRelPose,float &infoScale,MatrixXf &infoPose,int nb_iter)
{
	bool verb_BA=false;
	
	KeyFrame &KFc=KeyFrameList[_kfcurr];
	KeyFrame &KFn=KeyFrameList[_kfneigb];

	if(verb_BA)std::cout<<"\ttest innerWindowKFs passed"<<std::endl;
	//we are going to optimise over scale of each KF and relative pose between KF
	//only the pose and scale of second kf are optimised
	float scales_kf2=optRelScale;
	//HomogeneousMatrix pose_kf2=KFn.getPose();
	HomogeneousMatrix pose_kf2=optRelPose.inverse()*KFc.getPose();
	int nbOptimKf=1;
	
	//std::cout<<"relPoseBefore = "<<KFc.getPose()*KFn.getPose().inverse()<<std::endl;
			
	if(verb_BA)std::cout<<"\tvariables allocated and LUT init"<<std::endl;
	//first few iterations on pose
	for(int iter=0;iter<50;iter++)
	{
		//if(verb_BA)std::cout<<"\t###############################################"<<std::endl;
		//if(verb_BA)std::cout<<"\tIteration "<<iter<<std::endl;
		//need to put in minimisation all the points linked by features of innerWindow and outerWindow
		//that should be all the points defined in this keyframes
		std::vector<kf_loc_scal_jac> list_jacobian_scale;
		
		HomogeneousMatrix pose_c=KFc.getPose();
		HomogeneousMatrix pose_n=pose_kf2;		
		HomogeneousMatrix relPose=pose_c*pose_n.inverse();
		
		//to get from relPose to deriv wrt pose_c and pose_n
		MatrixXf M1(6,6);
		VectorXf logRelPose=relPose.get_p();
		Vector3f Dt;for(int j=0;j<3;j++)Dt[j]=logRelPose[j];
		Vector3f Dw;for(int j=0;j<3;j++)Dw[j]=logRelPose[j+3];
		M1.block(0,0,3,3)=-GetSkew(Dw);
		M1.block(3,3,3,3)=-GetSkew(Dw);
		M1.block(0,3,3,3)=-GetSkew(Dt);
		M1.block(3,0,3,3).setZero();
		MatrixXf dHErr_dpn=-(MatrixXf::Identity(6,6)-0.5*M1);
		
		float residue=0;
		float nb_residue=0;

		//get neigbors
		for(int n=0;n<KFc.getNbNeigbours();n++)
		{
			NeigbourKFNew &neigbor=*KFc.getPtNeigbour(n);
			if(neigbor.neighboring_kf==_kfneigb)//can do optim only if kf2 is neighbor of kf1
			{
				
				if(verb_BA)std::cout<<"\tnb matches = "<<neigbor.matches.size()<<std::endl;
				for(int m=0;m<neigbor.matches.size();m++)
				{
					p_match &mMatch=neigbor.matches[m];
					//if matches are linked to local features then can use them for pose and scale alignment
					//TODO put all the match features in cach not to have to go through the search everytime
					int idFeat_c=KFc.indexCandidateFeatureFromVisoId(mMatch.i1c);
					int idFeat_n=KFn.indexCandidateFeatureFromVisoId(mMatch.i1p);
					if(idFeat_c!=-1 && idFeat_n!=-1)
					{
						//get current estimated scales
							
						float scale_n=scales_kf2;
							
						uptoscaleFeature *feat_c=KFc.getPtLocalBestFeatures(idFeat_c);
						uptoscaleFeature *feat_n=KFn.getPtLocalBestFeatures(idFeat_n);
						Vector3f scaleError=feat_c->getLocalCoordinates()-relPose*(scale_n*feat_n->getLocalCoordinates());
						residue+=scaleError.squaredNorm();
						nb_residue++;
						
						
						//deriv with respect to relPose:
						MatrixXf jac_dp(3,6);
						jac_dp.block(0,0,3,3)=-Matrix3f::Identity();
						jac_dp.block(0,3,3,3)=GetSkew(relPose*(scale_n*feat_n->getLocalCoordinates()));
					
						
						kf_loc_scal_jac mJacScale;
						mJacScale.pos_error=scaleError;
						mJacScale.weight=1.;
						
						
						mJacScale.opt_idn=0;
						//mJacScale.de_dpn=jac_dp*dHErr_dpn;
						mJacScale.de_dpn=jac_dp;//instead will multiply Jte directly later
						mJacScale.de_dsn=-relPose.get_rotation()*  feat_n->getLocalCoordinates();
						list_jacobian_scale.push_back(mJacScale);
					}

				}
				
			}
		}
		if(iter==0 || iter==nb_iter-1)std::cout<<"residue/	nb_residue = "<<	residue/	nb_residue<<std::endl;			
		
		//accumulate jacobians
		int nb_params=6*nbOptimKf;//scale + translation + rotation
		VectorXf Jte(nb_params);Jte.setZero();
		MatrixXf H(nb_params,nb_params);H.setZero();
				
		//std::cout<<"Update Matrices using jacobianScale"<<std::endl;
		for(int j=0;j<list_jacobian_scale.size();j++)
		{
			kf_loc_scal_jac &fJacobian=list_jacobian_scale[j];
			
			Jte.segment(6*fJacobian.opt_idn,6)+=fJacobian.weight * fJacobian.de_dpn.transpose()*fJacobian.pos_error;
			
			H.block(6*fJacobian.opt_idn,6*fJacobian.opt_idn,6,6)+=fJacobian.weight * fJacobian.de_dpn.transpose() * fJacobian.de_dpn;				
		}
		
		Jte.segment(0,6)=dHErr_dpn.transpose()*Jte.segment(0,6);
		H.block(0,0,6,6)=dHErr_dpn.transpose()*H.block(0,0,6,6)*dHErr_dpn.transpose();

		Eigen::FullPivLU<MatrixXf> lu(H);
		MatrixXf invH=lu.inverse();
		
		if(isnan(invH(0,0)))
		{
			std::cout<<"invHessian is nan"<<std::endl;
			break;
		}
		else
		{
			VectorXf Dp(nb_params);
			Dp=-0.6*(invH*Jte);
			
			if(verb_BA)std::cout<<"\tapply update"<<std::endl;
			VectorXf dp(Dp.segment(0,6));
			pose_kf2=HomogeneousMatrix(dp)* pose_kf2;
			
		}	
	}
	
	for(int iter=0;iter<nb_iter;iter++)
	{
		//if(verb_BA)std::cout<<"\t###############################################"<<std::endl;
		//if(verb_BA)std::cout<<"\tIteration "<<iter<<std::endl;
		//need to put in minimisation all the points linked by features of innerWindow and outerWindow
		//that should be all the points defined in this keyframes
		std::vector<kf_loc_scal_jac> list_jacobian_scale;
		
		HomogeneousMatrix pose_c=KFc.getPose();
		HomogeneousMatrix pose_n=pose_kf2;		
		HomogeneousMatrix relPose=pose_c*pose_n.inverse();
		
		//to get from relPose to deriv wrt pose_c and pose_n
		MatrixXf M1(6,6);
		VectorXf logRelPose=relPose.get_p();
		Vector3f Dt;for(int j=0;j<3;j++)Dt[j]=logRelPose[j];
		Vector3f Dw;for(int j=0;j<3;j++)Dw[j]=logRelPose[j+3];
		M1.block(0,0,3,3)=-GetSkew(Dw);
		M1.block(3,3,3,3)=-GetSkew(Dw);
		M1.block(0,3,3,3)=-GetSkew(Dt);
		M1.block(3,0,3,3).setZero();
		MatrixXf dHErr_dpn=-(MatrixXf::Identity(6,6)-0.5*M1);
		
		float residue=0;
		float nb_residue=0;

		//get neigbors
		for(int n=0;n<KFc.getNbNeigbours();n++)
		{
			NeigbourKFNew &neigbor=*KFc.getPtNeigbour(n);
			if(neigbor.neighboring_kf==_kfneigb)//can do optim only if kf2 is neighbor of kf1
			{
				
				if(verb_BA)std::cout<<"\tnb matches = "<<neigbor.matches.size()<<std::endl;
				for(int m=0;m<neigbor.matches.size();m++)
				{
					p_match &mMatch=neigbor.matches[m];
					//if matches are linked to local features then can use them for pose and scale alignment
					//TODO put all the match features in cach not to have to go through the search everytime
					int idFeat_c=KFc.indexCandidateFeatureFromVisoId(mMatch.i1c);
					int idFeat_n=KFn.indexCandidateFeatureFromVisoId(mMatch.i1p);
					if(idFeat_c!=-1 && idFeat_n!=-1)
					{
						//get current estimated scales
							
						float scale_n=scales_kf2;
							
						uptoscaleFeature *feat_c=KFc.getPtLocalBestFeatures(idFeat_c);
						uptoscaleFeature *feat_n=KFn.getPtLocalBestFeatures(idFeat_n);
						Vector3f scaleError=feat_c->getLocalCoordinates()-relPose*(scale_n*feat_n->getLocalCoordinates());
						residue+=scaleError.squaredNorm();
						nb_residue++;
						
						
						//deriv with respect to relPose:
						MatrixXf jac_dp(3,6);
						jac_dp.block(0,0,3,3)=-Matrix3f::Identity();
						jac_dp.block(0,3,3,3)=GetSkew(relPose*(scale_n*feat_n->getLocalCoordinates()));
					
						
						kf_loc_scal_jac mJacScale;
						mJacScale.pos_error=scaleError;
						mJacScale.weight=1.;
						
						
						mJacScale.opt_idn=0;
						//mJacScale.de_dpn=jac_dp*dHErr_dpn;
						mJacScale.de_dpn=jac_dp;//instead will multiply Jte directly later
						mJacScale.de_dsn=-relPose.get_rotation()*  feat_n->getLocalCoordinates();
						list_jacobian_scale.push_back(mJacScale);
					}

				}
				
			}
		}
		if(iter==0 || iter==nb_iter-1)std::cout<<"residue/	nb_residue = "<<	residue/	nb_residue<<std::endl;			
		
		//accumulate jacobians
		int nb_params=7*nbOptimKf;//scale + translation + rotation
		VectorXf Jte(nb_params);Jte.setZero();
		MatrixXf H(nb_params,nb_params);H.setZero();
				
		//std::cout<<"Update Matrices using jacobianScale"<<std::endl;
		for(int j=0;j<list_jacobian_scale.size();j++)
		{
			kf_loc_scal_jac &fJacobian=list_jacobian_scale[j];
			
			Jte[7*fJacobian.opt_idn]+=fJacobian.weight * fJacobian.de_dsn.transpose()*fJacobian.pos_error;
			Jte.segment(7*fJacobian.opt_idn+1,6)+=fJacobian.weight * fJacobian.de_dpn.transpose()*fJacobian.pos_error;
			
			H(7*fJacobian.opt_idn,7*fJacobian.opt_idn)+=fJacobian.weight * fJacobian.de_dsn.transpose() * fJacobian.de_dsn;				
			H.block(7*fJacobian.opt_idn+1,7*fJacobian.opt_idn+1,6,6)+=fJacobian.weight * fJacobian.de_dpn.transpose() * fJacobian.de_dpn;				
		}
		//keep information matrix wrt relative pose
		MatrixXf InformationMatrixRelPose=H.block(1,1,6,6);
		
		Jte.segment(1,6)=dHErr_dpn.transpose()*Jte.segment(1,6);
		H.block(1,1,6,6)=dHErr_dpn.transpose()*H.block(1,1,6,6)*dHErr_dpn.transpose();

		Eigen::FullPivLU<MatrixXf> lu(H);
		MatrixXf invH=lu.inverse();
		
		if(isnan(invH(0,0)))
		{
			std::cout<<"invHessian is nan"<<std::endl;
			break;
		}
		else
		{
			VectorXf Dp(nb_params);
			Dp=-0.6*(invH*Jte);
			
			if(verb_BA)std::cout<<"\tapply update"<<std::endl;
			float ds=Dp[0];
			//scales_kfs[j]=(1.+ds)*scales_kfs[j];
			scales_kf2=ds+scales_kf2;
			VectorXf dp(Dp.segment(1,6));
			pose_kf2=HomogeneousMatrix(dp)* pose_kf2;
			
		}
		
		optRelScale=scales_kf2;
		optRelPose=pose_c*pose_kf2.inverse();
		infoScale=H(0,0);
		infoPose=InformationMatrixRelPose;		
	}
	std::cout<<"optRelScale = "<<optRelScale<<std::endl;
	
	//for testing
	/*for(int f=0;f<KFn.getNbLocalBestFeatures();f++)
		KFn.getPtLocalBestFeatures(f)->depthInRef*=scales_kf2;
	
	HomogeneousMatrix relBestPose= KFn.getBestRelPose();
	relBestPose.set_translation(relBestPose.get_translation()*scales_kf2);
	KFn.setBestRelPose(relBestPose);*/
	

	
}
float obMap::getReprojectionError()
{
	float error=0;
	float nberror=0;
	for(int k=0;k<KeyFrameList.size();k++)
	{
		KeyFrame &kfc=*getKF(k);
		for(int p=0;p<kfc.getNbMapPoint();p++)
		{
			MapPoint &point=*kfc.getPtMapPoint(p);
			if(point.isUsed())
			{
				//go through all view of point and change current id==p to p2
				for(int v=0;v<point.nbViews();v++)
				{
					int kfView=point.getView(v);
					int i1pView=point.getI1p(v);
					//get corresponding local feature:
					int id_feat_v=KeyFrameList[kfView].indexCandidateFeatureFromVisoId(i1pView);
					if(id_feat_v!=-1)
					{
						uptoscaleFeature &feat_v=*KeyFrameList[kfView].getPtLocalBestFeatures(id_feat_v);
						Vector2f projMapPoint=myCamera->Project(KeyFrameList[kfView].getPose()*point.getPosition());
						Vector2f posLocalFeature=myCamera->ToPixels(feat_v.posRef);
						error+=sqrt((projMapPoint-posLocalFeature).squaredNorm());
						nberror++;
					}
					
				}

			}

		} 
	}
	return error/nberror;
}
